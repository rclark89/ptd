use std::io; //io is input/output library, taken from the std standard library
use rand::Rng;
use lettre_email::EmailBuilder;
use lettre::smtp::authentication::Credentials;
use lettre::{SmtpClient, Transport};
use chrono::{TimeZone, Utc, DateTime};


fn main() {

	let position = posname();
	
	let engineer = engname();
	
	let safe = yesno();
	
	services();
	
	send();
	
	let code = randomcode();
	
	let dt = datetime();
	
	let emailtext = format!(
	"\nThis email is from an automated inbox. Do not reply. 
	\nPermit to dig number: {} {} \n
	\nPosition name: {} \n
	\nEngineer name: {} \n
	\nThe following services have been located: \n
	\nIt is {} \n", 
	&code, &dt, &position, &engineer, &safe
	);
	
	let email = EmailBuilder::new() //creates new email item
        .to("---------------")
		.to("---------------")
        .from("---------------")
        .subject("Permit to dig")
        .text(emailtext)
		//.text("This permit applies to {}.",loc)
		//.text("This permit was generated by {}.",person)
		//.text("Is it safe to dig? {}.",safe)
        .build()
        .unwrap();
		
    let mut mailer = SmtpClient::new_simple("smtp.zoho.eu") //sends email via Smtp - the simplest way of doing this!
        .unwrap()
        .credentials(Credentials::new("---------------".into(), "---------------".into()))
        .transport();

    let result = mailer.send(email.into());

    println!("{:?}", result);

}

fn randomcode() -> i64 {
	let uniquecode = rand::thread_rng().gen_range(1..=10000);
	println!("Permit reference {}",uniquecode);
	return uniquecode;

}

fn datetime() -> DateTime<Utc> {
	let dt = Utc::now();
	let unixtimestamp: i64 = dt.timestamp();
	let corrdt = Utc.timestamp(unixtimestamp, 0);
	return corrdt;
}

fn posname() -> String {
	let mut position = String::new();
	println!("Please input position name.");
	io::stdin() //calls stdin user input function from io module.
		.read_line(&mut position) //passing &mut guess as the argument to read_line method.
		// read_line takes user input and appends to a string. & indicates this is a reference.
		.expect("Failed to read line"); //Error handling.
		println!("This permit applies to {}",position);
	
	return position
}

fn engname() -> String {

	let mut engineer = String::new();
		println!("Please input engineer name.");
		io::stdin() //calls stdin user input function from io module.
			.read_line(&mut engineer) //passing &mut guess as the argument to read_line method.
			// read_line takes user input and appends to a string. & indicates this is a reference.
			.expect("Failed to read line"); //Error handling.
			println!("This permit was generated by {}",engineer);
		
		return engineer
			
}

fn send() {
    println!("This permit will be emailed to the specified users.");
}

fn yesno() -> String {
	let mut input = String::new();
	println!("Is it safe to dig? Y/N");
	io::stdin() //calls stdin user input function from io module.
		.read_line(&mut input) //passing &mut guess as the argument to read_line method.
		// read_line takes user input and appends to a string. & indicates this is a reference.
		.expect("Failed to read line"); //Error handling.
		if input.trim().to_lowercase() == "y" {
			println!("Safe to dig.");
			let outputyn = "safe to dig.".to_string();
			return outputyn;
		} else if input.trim().to_lowercase() == "n" {
			println!("Not safe to dig.");
			let outputyn = "not safe to dig. Do not proceed.".to_string();
			return outputyn;
		} else {
			println!("Invalid input.");
			let outputyn = "Invalid input".to_string();
			return outputyn
		}
}

fn services() -> Vec<String> {
    let svcs = ["Gas", "Electricity", "Water"];

    for item in svcs { //add outputsvcs
		let mut input = String::new();
		let mut list = vec![];
		println!("Is {} present? Y/N",item);
		io::stdin()
			.read_line(&mut input)
			.expect("Failed to read line");
			if input.trim().to_lowercase() == "y" {
				println!("{} is present",item);
				&mut list.push(item.to_string());
			} else if input.trim().to_lowercase() == "n" {
				println!("{} is not present",item);
			} else {
				println!("Invalid input.");
			}
		}
	

}

