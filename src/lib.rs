use std::io; //io is input/output library, taken from the std standard library
use rand::Rng;
use chrono::{TimeZone, Utc, DateTime};
use std::fs::File;
use std::io::Write;
use std::fs::OpenOptions;
//use std::str::as_bytes;


pub fn randomcode() -> i64 {
	let uniquecode = rand::thread_rng().gen_range(1..=10000);
	println!("Permit reference {}",uniquecode);
	return uniquecode;

}

pub fn datetime() -> DateTime<Utc> {
	let dt = Utc::now();
	let unixtimestamp: i64 = dt.timestamp();
	let corrdt = Utc.timestamp(unixtimestamp, 0);
	return corrdt;
}

pub fn posname() -> String {
	let mut position = String::new();
	println!("Please input position name.");
	io::stdin() //calls stdin user input function from io module.
		.read_line(&mut position) //passing &mut guess as the argument to read_line method.
		// read_line takes user input and appends to a string. & indicates this is a reference.
		.expect("Failed to read line"); //Error handling.
		println!("This permit applies to {}",position);
	
	return position
}

pub fn engname() -> String {

	let mut engineer = String::new();
		println!("Please input engineer name.");
		io::stdin() //calls stdin user input function from io module.
			.read_line(&mut engineer) //passing &mut guess as the argument to read_line method.
			// read_line takes user input and appends to a string. & indicates this is a reference.
			.expect("Failed to read line"); //Error handling.
			println!("This permit was generated by {}",engineer);
		
		return engineer
			
}


pub fn yesno() -> String {
	let mut input = String::new();
	println!("Is it safe to dig? Y/N");
	io::stdin() //calls stdin user input function from io module.
		.read_line(&mut input) //passing &mut guess as the argument to read_line method.
		// read_line takes user input and appends to a string. & indicates this is a reference.
		.expect("Failed to read line"); //Error handling.
		if input.trim().to_lowercase() == "y" {
			println!("Safe to dig.");
			let outputyn = "safe to dig.".to_string();
			return outputyn;
		} else if input.trim().to_lowercase() == "n" {
			println!("Not safe to dig.");
			let outputyn = "not safe to dig. Do not proceed.".to_string();
			return outputyn;
		} else {
			println!("Invalid input.");
			let outputyn = "Invalid input".to_string();
			return outputyn
		}
}

pub fn gas() -> String {
  
	let mut ginput = String::new();
		println!("Is gas present? Y/N");
	io::stdin()
		.read_line(&mut ginput)
		.expect("Failed to read line");
		if ginput.trim().to_lowercase() == "y" {
			println!("Gas is present");
			let outputgas = "Gas is present.".to_string();
			return outputgas
		} else if ginput.trim().to_lowercase() == "n" {
			println!("Gas is not present");
			let outputgas = "Gas is not present.".to_string();
			return outputgas
		} else {
			println!("Invalid input.");
			let outputgas = "Invalid input".to_string();
			return outputgas
		}
			
}

pub fn elec() -> String {
	
	let mut einput = String::new();
		println!("Is electricity present? Y/N");
	io::stdin()
		.read_line(&mut einput)
		.expect("Failed to read line");
		if einput.trim().to_lowercase() == "y" {
			println!("Electricity is present");
			let outputlec = "Electricity is present.".to_string();
			return outputlec
		} else if einput.trim().to_lowercase() == "n" {
			println!("Electricity is not present");
			let outputlec = "Electricity is not present.".to_string();
			return outputlec
		} else {
			println!("Invalid input.");
			let outputlec = "Invalid input".to_string();
			return outputlec
		}
			
}

pub fn water() -> String {	

	let mut winput = String::new();
		println!("Is water present? Y/N");
	io::stdin()
		.read_line(&mut winput)
		.expect("Failed to read line");
		if winput.trim().to_lowercase() == "y" {
			println!("Water is present");
			let outputw = "Water is present.".to_string();
			return outputw
		} else if winput.trim().to_lowercase() == "n" {
			println!("Water is not present");
			let outputw = "Water is not present.".to_string();
			return outputw
		} else {
			println!("Invalid input.");
			let outputw = "Invalid input".to_string();
			return outputw
		}		
	
	
}



pub fn new_logfile() -> String {
	
	
	let mut log_input = String::new();
		println!("Do you need to produce a new logfile?");
	io::stdin()
		.read_line(&mut log_input)
		.expect("Failed to read line");
		if log_input.trim().to_lowercase() == "y" {
			let file_name = "logfile.txt";
			let outputlog = "Logfile created".to_string();
	
			File::create("C:/Users/Ross/Documents/logfiles/logfile.txt") // To do: let user specify file name.
			.expect("Error: failed to create file.");
			
			return outputlog
		} else if log_input.trim().to_lowercase() == "n" {
			println!("Logfile creation not required.");
			let outputlog = "Logfile not required".to_string();
			return outputlog
		} else {
			println!("Invalid input.");
			let outputlog = "Invalid input".to_string();
			return outputlog
		}

			
		
}

//pub struct log_file_update

pub fn append_to_log(user:String,dtime:DateTime<Utc>,permitno:i64) -> String {
	
	let mut update_input = String::new();
		println!("Add to logfile?");
	io::stdin()
		.read_line(&mut update_input)
		.expect("Failed to read line");
		if update_input.trim().to_lowercase() == "y" {
			let updatelog = "Logfile updated".to_string();

			
			let mut file = OpenOptions::new()
				.write(true)
				.append(true)
				.open("C:/Users/Ross/Documents/logfiles/logfile.txt") // To do: let user specify file name.
				.unwrap();
			
			let logfile_contents = format!("Logfile entry 1 \n
			{}\n
			{}\n
			{}\n", &user,&dtime,&permitno);
			
			file.write_all(logfile_contents.as_bytes())
			.expect("Error: failed to create file.");
			
			return updatelog
		} else if update_input.trim().to_lowercase() == "n" {
			println!("Logfile creation not required.");
			let updatelog = "Logfile not updated".to_string();
			return updatelog
		} else {
			println!("Invalid input.");
			let updatelog = "Invalid input".to_string();
			return updatelog
		}
}
		
/* pub fn emaileng() -> String{
	
	let mut email1 = String::new();
		println!("Please input your email address.");
		io::stdin() //calls stdin user input function from io module.
			.read_line(&mut email1) //passing &mut guess as the argument to read_line method.
			// read_line takes user input and appends to a string. & indicates this is a reference.
			.expect("Failed to read email address"); //Error handling.
			let email1output = email1.to_string();
			return email1output;
}
			
pub fn emailsup() -> String{
			
	let mut email2 = String::new();
		println!("Please input your supervisor's email address.");
		io::stdin() //calls stdin user input function from io module.
			.read_line(&mut email2) //passing &mut guess as the argument to read_line method.
			// read_line takes user input and appends to a string. & indicates this is a reference.
			.expect("Failed to read email address"); //Error handling.
			let email2output = email2.to_string();
			return email2output;
	
	
}	 */